#!/usr/bin/env python3
"""
QuickJS-ng Binding Generator for wisp browser.

Generates C bindings for QuickJS-ng from WebIDL files.

Usage:
    python qjs_binding_generator.py <idl_file> -o <output_dir>
    python qjs_binding_generator.py console.idl -o src/content/handlers/javascript/quickjs/
"""

import os
import sys
import argparse
from datetime import datetime

try:
    import widlparser
except ImportError:
    print("Error: widlparser not installed. Install via: pip install widlparser")
    sys.exit(1)


class QuickJSBindingGenerator:
    """Generates QuickJS-ng C bindings from WebIDL."""
    
    def __init__(self, output_dir: str):
        self.output_dir = output_dir
        self.parser = widlparser.Parser()
        
    def parse_idl(self, idl_path: str):
        """Parse an IDL file."""
        with open(idl_path, 'r') as f:
            self.parser.parse(f.read())
            
    def generate_console(self) -> str:
        """Generate Console binding C code."""
        console = self.parser.find('Console')
        if not console:
            raise ValueError("Console interface not found in parsed IDL")
        
        # Extract method names
        methods = []
        for member in console.members:
            if hasattr(member, 'name') and member.name:
                methods.append(member.name)
        
        code = self._generate_console_c(methods)
        return code
    
    def _generate_console_c(self, methods: list) -> str:
        """Generate the console.c file content."""
        year = datetime.now().year
        
        code = f'''/*
 * Copyright {year} Neosurf Contributors
 *
 * This file is part of Wisp, http://www.wisp-browser.org/
 *
 * Generated by qjs_binding_generator.py - DO NOT EDIT MANUALLY
 *
 * Wisp is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 */

/**
 * \\file
 * QuickJS-ng Console interface binding.
 */

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

#include <wisp/utils/errors.h>
#include <wisp/utils/log.h>
#include <wisp/browser_window.h>
#include <nsutils/time.h>

#include "quickjs.h"

/* Forward declarations */
static JSValue js_console_log(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_error(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_warn(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_info(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_debug(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_dir(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_group(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_groupCollapsed(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_groupEnd(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_time(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_timeEnd(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
static JSValue js_console_trace(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);

/* Console private data - only simple types, no JSValue */
typedef struct {{
    unsigned int group_level;
}} ConsolePrivate;

/* Hidden property name for timers */
#define CONSOLE_TIMERS_PROP "_timers"

/* Class ID for Console */
static JSClassID js_console_class_id;

/**
 * Helper to write a log entry to the browser console.
 */
static void
write_log_entry(JSContext *ctx, unsigned int group_level, 
                browser_window_console_flags flags, 
                int argc, JSValueConst *argv)
{{
    /* Build the message string from all arguments */
    char *msg = NULL;
    size_t msg_len = 0;
    
    for (int i = 0; i < argc; i++) {{
        const char *str = JS_ToCString(ctx, argv[i]);
        if (str) {{
            size_t str_len = strlen(str);
            char *new_msg = realloc(msg, msg_len + str_len + 2);
            if (new_msg) {{
                msg = new_msg;
                if (msg_len > 0) {{
                    msg[msg_len++] = ' ';
                }}
                memcpy(msg + msg_len, str, str_len);
                msg_len += str_len;
                msg[msg_len] = '\\0';
            }}
            JS_FreeCString(ctx, str);
        }}
    }}
    
    if (msg == NULL) {{
        msg = strdup("");
        msg_len = 0;
    }}
    
    /* Add indentation for groups */
    if (group_level > 0) {{
        size_t indent_len = group_level * 2;
        char *indented = malloc(indent_len + msg_len + 1);
        if (indented) {{
            memset(indented, ' ', indent_len);
            memcpy(indented + indent_len, msg, msg_len + 1);
            free(msg);
            msg = indented;
            msg_len += indent_len;
        }}
    }}
    
    /* Log to NSLOG for now - browser_window_console_log requires window context */
    switch (flags) {{
    case BW_CS_FLAG_LEVEL_ERROR:
        NSLOG(wisp, ERROR, "Console: %s", msg);
        break;
    case BW_CS_FLAG_LEVEL_WARN:
        NSLOG(wisp, WARNING, "Console: %s", msg);
        break;
    default:
        NSLOG(wisp, INFO, "Console: %s", msg);
        break;
    }}
    
    free(msg);
}}

/**
 * Get Console private data from this value.
 */
static ConsolePrivate *
js_console_get_private(JSContext *ctx, JSValueConst this_val)
{{
    return JS_GetOpaque(this_val, js_console_class_id);
}}

/* Console.log() */
static JSValue
js_console_log(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    write_log_entry(ctx, group, BW_CS_FLAG_LEVEL_LOG, argc, argv);
    return JS_UNDEFINED;
}}

/* Console.error() */
static JSValue
js_console_error(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    write_log_entry(ctx, group, BW_CS_FLAG_LEVEL_ERROR, argc, argv);
    return JS_UNDEFINED;
}}

/* Console.warn() */
static JSValue
js_console_warn(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    write_log_entry(ctx, group, BW_CS_FLAG_LEVEL_WARN, argc, argv);
    return JS_UNDEFINED;
}}

/* Console.info() */
static JSValue
js_console_info(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    write_log_entry(ctx, group, BW_CS_FLAG_LEVEL_INFO, argc, argv);
    return JS_UNDEFINED;
}}

/* Console.debug() */
static JSValue
js_console_debug(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    write_log_entry(ctx, group, BW_CS_FLAG_LEVEL_DEBUG, argc, argv);
    return JS_UNDEFINED;
}}

/* Console.dir() */
static JSValue
js_console_dir(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    write_log_entry(ctx, group, BW_CS_FLAG_LEVEL_INFO, argc, argv);
    return JS_UNDEFINED;
}}

/* Console.group() */
static JSValue
js_console_group(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    if (priv) {{
        priv->group_level++;
    }}
    return JS_UNDEFINED;
}}

/* Console.groupCollapsed() */
static JSValue
js_console_groupCollapsed(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    if (priv) {{
        priv->group_level++;
    }}
    return JS_UNDEFINED;
}}

/* Console.groupEnd() */
static JSValue
js_console_groupEnd(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    if (priv && priv->group_level > 0) {{
        priv->group_level--;
    }}
    return JS_UNDEFINED;
}}

/* Console.time() */
static JSValue
js_console_time(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    if (argc < 1 || !JS_IsString(argv[0])) {{
        return JS_ThrowTypeError(ctx, "Console.time() requires a string argument");
    }}
    
    uint64_t time_ms = 0;
    if (nsu_getmonotonic_ms(&time_ms) != NSUERROR_OK) {{
        return JS_UNDEFINED;
    }}
    
    /* Get timers object from console as a property */
    JSValue timers = JS_GetPropertyStr(ctx, this_val, CONSOLE_TIMERS_PROP);
    if (!JS_IsUndefined(timers)) {{
        const char *name = JS_ToCString(ctx, argv[0]);
        if (name) {{
            JS_SetPropertyStr(ctx, timers, name, JS_NewFloat64(ctx, (double)time_ms));
            JS_FreeCString(ctx, name);
        }}
    }}
    JS_FreeValue(ctx, timers);
    
    return JS_UNDEFINED;
}}

/* Console.timeEnd() */
static JSValue
js_console_timeEnd(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    if (argc < 1 || !JS_IsString(argv[0])) {{
        return JS_ThrowTypeError(ctx, "Console.timeEnd() requires a string argument");
    }}
    
    uint64_t time_ms = 0;
    if (nsu_getmonotonic_ms(&time_ms) != NSUERROR_OK) {{
        return JS_UNDEFINED;
    }}
    
    /* Get timers object from console as a property */
    JSValue timers = JS_GetPropertyStr(ctx, this_val, CONSOLE_TIMERS_PROP);
    if (!JS_IsUndefined(timers)) {{
        const char *name = JS_ToCString(ctx, argv[0]);
        if (name) {{
            JSValue old_time_val = JS_GetPropertyStr(ctx, timers, name);
            
            if (!JS_IsUndefined(old_time_val)) {{
                double old_time = 0;
                JS_ToFloat64(ctx, &old_time, old_time_val);
                uint64_t elapsed = time_ms - (uint64_t)old_time;
                
                NSLOG(wisp, INFO, "Console: %s: %llu ms", name, (unsigned long long)elapsed);
                
                JSAtom atom = JS_NewAtom(ctx, name);
                JS_DeleteProperty(ctx, timers, atom, 0);
                JS_FreeAtom(ctx, atom);
            }}
            JS_FreeValue(ctx, old_time_val);
            JS_FreeCString(ctx, name);
        }}
    }}
    JS_FreeValue(ctx, timers);
    
    return JS_UNDEFINED;
}}

/* Console.trace() */
static JSValue
js_console_trace(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    ConsolePrivate *priv = js_console_get_private(ctx, this_val);
    unsigned int group = priv ? priv->group_level : 0;
    
    /* Get stack trace by creating an Error and getting its stack */
    JSValue error = JS_NewError(ctx);
    JSValue stack = JS_GetPropertyStr(ctx, error, "stack");
    
    const char *stack_str = JS_ToCString(ctx, stack);
    if (stack_str) {{
        NSLOG(wisp, INFO, "Console trace:\\n%s", stack_str);
        JS_FreeCString(ctx, stack_str);
    }}
    
    JS_FreeValue(ctx, stack);
    JS_FreeValue(ctx, error);
    
    return JS_UNDEFINED;
}}

/* Console class finalizer */
static void
js_console_finalizer(JSRuntime *rt, JSValue val)
{{
    ConsolePrivate *priv = JS_GetOpaque(val, js_console_class_id);
    if (priv) {{
        /* timers is freed by GC */
        free(priv);
    }}
}}

/* Console class definition */
static JSClassDef js_console_class = {{
    "Console",
    .finalizer = js_console_finalizer,
}};

/* Console method list */
static const JSCFunctionListEntry js_console_proto_funcs[] = {{
    JS_CFUNC_DEF("log", 0, js_console_log),
    JS_CFUNC_DEF("error", 0, js_console_error),
    JS_CFUNC_DEF("warn", 0, js_console_warn),
    JS_CFUNC_DEF("info", 0, js_console_info),
    JS_CFUNC_DEF("debug", 0, js_console_debug),
    JS_CFUNC_DEF("dir", 1, js_console_dir),
    JS_CFUNC_DEF("group", 0, js_console_group),
    JS_CFUNC_DEF("groupCollapsed", 0, js_console_groupCollapsed),
    JS_CFUNC_DEF("groupEnd", 0, js_console_groupEnd),
    JS_CFUNC_DEF("time", 1, js_console_time),
    JS_CFUNC_DEF("timeEnd", 1, js_console_timeEnd),
    JS_CFUNC_DEF("trace", 0, js_console_trace),
}};

/**
 * Initialize Console class and create global console object.
 *
 * Call this after creating a JSContext to set up the console.
 */
int
qjs_init_console(JSContext *ctx)
{{
    JSValue global_obj;
    JSValue console_proto;
    JSValue console_obj;
    ConsolePrivate *priv;
    
    /* Get runtime */
    JSRuntime *rt = JS_GetRuntime(ctx);
    
    /* Create class ID if not already done */
    if (js_console_class_id == 0) {{
        JS_NewClassID(rt, &js_console_class_id);
    }}
    
    /* Register the class (only if not already registered in this runtime) */
    if (!JS_IsRegisteredClass(rt, js_console_class_id)) {{
        if (JS_NewClass(rt, js_console_class_id, &js_console_class) < 0) {{
            return -1;
        }}
    }}
    
    /* Create prototype */
    console_proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(ctx, console_proto, 
                               js_console_proto_funcs, 
                               sizeof(js_console_proto_funcs) / sizeof(js_console_proto_funcs[0]));
    JS_SetClassProto(ctx, js_console_class_id, console_proto);
    
    /* Create console object */
    console_obj = JS_NewObjectClass(ctx, js_console_class_id);
    
    /* Allocate and attach private data */
    priv = calloc(1, sizeof(ConsolePrivate));
    if (priv == NULL) {{
        JS_FreeValue(ctx, console_obj);
        return -1;
    }}
    priv->group_level = 0;
    JS_SetOpaque(console_obj, priv);
    
    /* Store timers as a property of the console object (GC handles it) */
    JS_SetPropertyStr(ctx, console_obj, CONSOLE_TIMERS_PROP, JS_NewObject(ctx));
    
    /* Set as global.console */
    global_obj = JS_GetGlobalObject(ctx);
    JS_SetPropertyStr(ctx, global_obj, "console", console_obj);
    JS_FreeValue(ctx, global_obj);
    
    return 0;
}}
'''
        return code
    
    def write_console_c(self, output_path: str = None):
        """Generate and write console.c file."""
        code = self.generate_console()
        
        if output_path is None:
            output_path = os.path.join(self.output_dir, 'console.c')
        
        with open(output_path, 'w') as f:
            f.write(code)
        
        print(f"Generated: {output_path}")
        return output_path

    def generate_generic_binding(self, interface_name: str) -> str:
        """Generate a generic stub binding for any interface."""
        interface = self.parser.find(interface_name)
        if not interface:
            raise ValueError(f"Interface '{interface_name}' not found in parsed IDL")
        
        methods = []
        for member in interface.members:
            if hasattr(member, 'name') and member.name:
                methods.append(member.name)
        
        return self._generate_generic_c(interface_name, methods)
    
    def _generate_generic_c(self, interface_name: str, methods: list) -> str:
        """Generate generic stub C code for an interface."""
        year = datetime.now().year
        lower_name = interface_name.lower()
        
        code = f'''/*
 * Copyright {year} Neosurf Contributors
 *
 * Generated by qjs_binding_generator.py - DO NOT EDIT MANUALLY
 */

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>

#include <wisp/utils/errors.h>
#include <wisp/utils/log.h>

#include "quickjs.h"

/* {interface_name} private data */
typedef struct {{
    void *private_ptr;
}} {interface_name}Private;

static JSClassID js_{lower_name}_class_id;

'''
        # Method stubs
        for method in methods:
            code += f'''static JSValue
js_{lower_name}_{method}(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{{
    NSLOG(wisp, INFO, "{interface_name}.{method}() called");
    return JS_UNDEFINED;
}}

'''

        # Finalizer
        code += f'''static void
js_{lower_name}_finalizer(JSRuntime *rt, JSValue val)
{{
    {interface_name}Private *priv = JS_GetOpaque(val, js_{lower_name}_class_id);
    if (priv) {{
        free(priv);
    }}
}}

static JSClassDef js_{lower_name}_class = {{
    "{interface_name}",
    .finalizer = js_{lower_name}_finalizer,
}};

static const JSCFunctionListEntry js_{lower_name}_proto_funcs[] = {{
'''
        for method in methods:
            code += f'    JS_CFUNC_DEF("{method}", 0, js_{lower_name}_{method}),\n'
            
        code += f'''}};

int
qjs_init_{lower_name}(JSContext *ctx)
{{
    JSRuntime *rt = JS_GetRuntime(ctx);
    
    if (js_{lower_name}_class_id == 0) {{
        JS_NewClassID(rt, &js_{lower_name}_class_id);
    }}
    
    if (!JS_IsRegisteredClass(rt, js_{lower_name}_class_id)) {{
        if (JS_NewClass(rt, js_{lower_name}_class_id, &js_{lower_name}_class) < 0) {{
            return -1;
        }}
    }}
    
    JSValue proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(ctx, proto, 
                               js_{lower_name}_proto_funcs, 
                               sizeof(js_{lower_name}_proto_funcs) / sizeof(js_{lower_name}_proto_funcs[0]));
    JS_SetClassProto(ctx, js_{lower_name}_class_id, proto);
    
    /* Window: attach methods to global and set self-references */
    if (strcmp("{interface_name}", "Window") == 0) {{
        JSValue global_obj = JS_GetGlobalObject(ctx);
        JS_SetPropertyFunctionList(ctx, global_obj, 
                                   js_{lower_name}_proto_funcs, 
                                   sizeof(js_{lower_name}_proto_funcs) / sizeof(js_{lower_name}_proto_funcs[0]));
        JS_SetPropertyStr(ctx, global_obj, "window", JS_DupValue(ctx, global_obj));
        JS_SetPropertyStr(ctx, global_obj, "self", JS_DupValue(ctx, global_obj));
        JS_SetPropertyStr(ctx, global_obj, "parent", JS_DupValue(ctx, global_obj));
        JS_SetPropertyStr(ctx, global_obj, "top", JS_DupValue(ctx, global_obj));
        JS_SetPropertyStr(ctx, global_obj, "frames", JS_DupValue(ctx, global_obj));
        JS_FreeValue(ctx, global_obj);
    }}
    
    return 0;
}}
'''
        return code

    def write_generic_binding(self, interface_name: str, output_path: str = None):
        """Generate and write a generic binding file."""
        code = self.generate_generic_binding(interface_name)
        
        if output_path is None:
            output_path = os.path.join(self.output_dir, f'{interface_name.lower()}.c')
        
        with open(output_path, 'w') as f:
            f.write(code)
        
        print(f"Generated: {output_path}")
        return output_path


def main():
    parser = argparse.ArgumentParser(
        description='Generate QuickJS-ng C bindings from WebIDL files'
    )
    parser.add_argument('idl_file', help='Path to the IDL file')
    parser.add_argument('-o', '--output', required=True, 
                        help='Output directory for generated C files')
    parser.add_argument('--interface', 
                        help='Specific interface to generate (e.g., Window)')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.idl_file):
        print(f"Error: IDL file not found: {args.idl_file}")
        sys.exit(1)
    
    os.makedirs(args.output, exist_ok=True)
    
    generator = QuickJSBindingGenerator(args.output)
    generator.parse_idl(args.idl_file)
    
    if args.interface:
        # Generate specific interface
        if args.interface == 'Console':
            generator.write_console_c()
        else:
            generator.write_generic_binding(args.interface)
    else:
        # Default: generate Console if found
        if generator.parser.find('Console'):
            generator.write_console_c()


if __name__ == '__main__':
    main()

